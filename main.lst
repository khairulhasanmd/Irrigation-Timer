   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	__vector_6
  12               	__vector_6:
  13               	.LFB6:
  14               		.file 1 "main.c"
   1:main.c        **** //**************************************************
   2:main.c        **** //  Author    - Md. Khairul Hasan
   3:main.c        **** //  Contact   - +880-1719-328628, 
   4:main.c        **** //  e-mail    - kairulhasanmd@gmail.com
   5:main.c        **** //  Device    - Hall effect sensor based motorcycle gear indicator.
   6:main.c        **** // **************************************************
   7:main.c        **** 
   8:main.c        **** // avrdude -p atmega8 -c usbasp -t -B 3
   9:main.c        **** // dump eeprom 0 512
  10:main.c        **** #include <avr/eeprom.h>
  11:main.c        **** #include <avr/io.h>
  12:main.c        **** #include <avr/interrupt.h>
  13:main.c        **** #include <util/delay.h>
  14:main.c        **** 
  15:main.c        **** #define F_CPU 1000000UL
  16:main.c        **** #define EEPROM_STORAGE_ADDRESS 0x08
  17:main.c        **** #define POWER_OFF_DETECT PD4
  18:main.c        **** #define SEGMENT_DOT PB7
  19:main.c        **** #define GEAR_SHIFT_UP PD0
  20:main.c        **** #define GEAR_SHIFT_DOWN PD1
  21:main.c        **** #define RESET_ALL PD2
  22:main.c        **** 
  23:main.c        **** volatile uint8_t secondFlag;
  24:main.c        **** uint8_t upState = 0, dwnState = 0;//for simple debounce purpose
  25:main.c        **** uint8_t gearCount = 0;
  26:main.c        **** uint8_t valueRead = 0;
  27:main.c        **** uint8_t buttonPressed = 0; 
  28:main.c        **** uint8_t states_of_segment[16] = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F, 0x77, 
  29:main.c        **** 
  30:main.c        **** ISR(TIMER1_COMPA_vect)
  31:main.c        **** {
  15               		.loc 1 31 0
  16               		.cfi_startproc
  17 0000 1F92      		push r1
  18               	.LCFI0:
  19               		.cfi_def_cfa_offset 3
  20               		.cfi_offset 1, -2
  21 0002 0F92      		push r0
  22               	.LCFI1:
  23               		.cfi_def_cfa_offset 4
  24               		.cfi_offset 0, -3
  25 0004 0FB6      		in r0,__SREG__
  26 0006 0F92      		push r0
  27 0008 1124      		clr __zero_reg__
  28 000a 8F93      		push r24
  29               	.LCFI2:
  30               		.cfi_def_cfa_offset 5
  31               		.cfi_offset 24, -4
  32               	/* prologue: Signal */
  33               	/* frame size = 0 */
  34               	/* stack size = 4 */
  35               	.L__stack_usage = 4
  32:main.c        ****   secondFlag = 1;
  36               		.loc 1 32 0
  37 000c 81E0      		ldi r24,lo8(1)
  38 000e 8093 0000 		sts secondFlag,r24
  39               	/* epilogue start */
  33:main.c        **** }
  40               		.loc 1 33 0
  41 0012 8F91      		pop r24
  42 0014 0F90      		pop r0
  43 0016 0FBE      		out __SREG__,r0
  44 0018 0F90      		pop r0
  45 001a 1F90      		pop r1
  46 001c 1895      		reti
  47               		.cfi_endproc
  48               	.LFE6:
  50               	.global	update_display
  52               	update_display:
  53               	.LFB7:
  34:main.c        **** 
  35:main.c        **** void update_display()
  36:main.c        **** {
  54               		.loc 1 36 0
  55               		.cfi_startproc
  56               	/* prologue: function */
  57               	/* frame size = 0 */
  58               	/* stack size = 0 */
  59               	.L__stack_usage = 0
  37:main.c        ****   //display the values
  38:main.c        ****   PORTB &= 0b10000000;
  60               		.loc 1 38 0
  61 001e 88B3      		in r24,0x18
  62 0020 8078      		andi r24,lo8(-128)
  63 0022 88BB      		out 0x18,r24
  39:main.c        ****   PORTB |= states_of_segment[gearCount];
  64               		.loc 1 39 0
  65 0024 98B3      		in r25,0x18
  66 0026 E091 0000 		lds r30,gearCount
  67 002a F0E0      		ldi r31,0
  68 002c E050      		subi r30,lo8(-(states_of_segment))
  69 002e F040      		sbci r31,hi8(-(states_of_segment))
  70 0030 8081      		ld r24,Z
  71 0032 892B      		or r24,r25
  72 0034 88BB      		out 0x18,r24
  73 0036 0895      		ret
  74               		.cfi_endproc
  75               	.LFE7:
  77               		.section	.text.startup,"ax",@progbits
  78               	.global	main
  80               	main:
  81               	.LFB8:
  40:main.c        **** }
  41:main.c        **** 
  42:main.c        **** int main (void)
  43:main.c        **** {
  82               		.loc 1 43 0
  83               		.cfi_startproc
  84               	/* prologue: function */
  85               	/* frame size = 0 */
  86               	/* stack size = 0 */
  87               	.L__stack_usage = 0
  44:main.c        ****   //initialize the I/O Ports
  45:main.c        ****   DDRC |= (1 << PC5)|(1 << PC4)|(1 << PC3)|(1 << PC2); //led in pc5,4,3,2,pins
  88               		.loc 1 45 0
  89 0000 84B3      		in r24,0x14
  90 0002 8C63      		ori r24,lo8(60)
  91 0004 84BB      		out 0x14,r24
  46:main.c        ****   DDRB |= (1 << PB0)|(1 << PB1)|(1 << PB2)|(1 << PB3)|(1 << PB4)|(1 << PB5)|(1 << PB6)|(1 << SEGMEN
  92               		.loc 1 46 0
  93 0006 87B3      		in r24,0x17
  94 0008 8FEF      		ldi r24,lo8(-1)
  95 000a 87BB      		out 0x17,r24
  47:main.c        ****   DDRD &= ~((1 << GEAR_SHIFT_UP)|(1 << GEAR_SHIFT_DOWN)|(1 << RESET_ALL)|(1 << POWER_OFF_DETECT)); 
  96               		.loc 1 47 0
  97 000c 81B3      		in r24,0x11
  98 000e 887E      		andi r24,lo8(-24)
  99 0010 81BB      		out 0x11,r24
  48:main.c        ****   PORTD |= (1 << GEAR_SHIFT_UP)|(1 << GEAR_SHIFT_DOWN)|(1 << RESET_ALL)|(1 << POWER_OFF_DETECT);   
 100               		.loc 1 48 0
 101 0012 82B3      		in r24,0x12
 102 0014 8761      		ori r24,lo8(23)
 103 0016 82BB      		out 0x12,r24
  49:main.c        **** 
  50:main.c        ****   TCCR1B |= (1 << WGM12);           // Configure timer 1 for CTC mode
 104               		.loc 1 50 0
 105 0018 8EB5      		in r24,0x2e
 106 001a 8860      		ori r24,lo8(8)
 107 001c 8EBD      		out 0x2e,r24
  51:main.c        ****   TIMSK |= (1 << OCIE1A);           // Enable CTC interrupt
 108               		.loc 1 51 0
 109 001e 89B7      		in r24,0x39
 110 0020 8061      		ori r24,lo8(16)
 111 0022 89BF      		out 0x39,r24
  52:main.c        ****   OCR1A = 15624;                // Set CTC compare value to 1Hz at 1MHz AVR clock, with a prescaler
 112               		.loc 1 52 0
 113 0024 88E0      		ldi r24,lo8(8)
 114 0026 9DE3      		ldi r25,lo8(61)
 115 0028 9BBD      		out 0x2a+1,r25
 116 002a 8ABD      		out 0x2a,r24
  53:main.c        ****   TCCR1B |= ((1 << CS10) | (1 << CS11));  // Start timer at Fcpu/64
 117               		.loc 1 53 0
 118 002c 8EB5      		in r24,0x2e
 119 002e 8360      		ori r24,lo8(3)
 120 0030 8EBD      		out 0x2e,r24
  54:main.c        **** 
  55:main.c        ****   //READ FROM EEPROM
  56:main.c        ****   valueRead = eeprom_read_byte((uint8_t*)EEPROM_STORAGE_ADDRESS);//read eeprom
 121               		.loc 1 56 0
 122 0032 88E0      		ldi r24,lo8(8)
 123 0034 90E0      		ldi r25,0
 124 0036 00D0      		rcall eeprom_read_byte
 125               	.LVL0:
 126 0038 8093 0000 		sts valueRead,r24
  57:main.c        ****   if (valueRead == 0xFFFF)//initial value.. omit it 
  58:main.c        ****   {
  59:main.c        ****     gearCount = 0;
  60:main.c        ****   }else{//has some value and its larger 
  61:main.c        ****     gearCount = valueRead;
 127               		.loc 1 61 0
 128 003c 8093 0000 		sts gearCount,r24
  62:main.c        ****   }
  63:main.c        **** 
  64:main.c        ****   sei();//Enable Global Interrupts
 129               		.loc 1 64 0
 130               	/* #APP */
 131               	 ;  64 "main.c" 1
 132 0040 7894      		sei
 133               	 ;  0 "" 2
  65:main.c        **** 
  66:main.c        ****   while (1)//main loop 
  67:main.c        ****   {
  68:main.c        ****     if (secondFlag){
  69:main.c        ****       secondFlag = 0;
  70:main.c        ****       update_display();
  71:main.c        ****       PORTB ^= (1 << SEGMENT_DOT);    // toggles the led
  72:main.c        ****     }
  73:main.c        **** 
  74:main.c        ****     //hall effect sensor functionality
  75:main.c        ****     if ((PIND & (1 << GEAR_SHIFT_UP)) && upState == 1){//reset up debounce
  76:main.c        ****       upState = 0;
  77:main.c        ****     }else if ((PIND & (1 << GEAR_SHIFT_DOWN)) && dwnState == 1){ //reset down debounce
  78:main.c        ****       dwnState = 0;
  79:main.c        ****     } else if ((!(PIND & (1 << GEAR_SHIFT_UP))) && upState == 0){  //if shift up detected
  80:main.c        ****       gearCount ++;
  81:main.c        ****       if(gearCount > 15){
  82:main.c        ****         gearCount = 0;
  83:main.c        ****       }
  84:main.c        ****       PORTB |= (1 << SEGMENT_DOT);    // light up the dot marker
  85:main.c        ****       upState = 1;
  86:main.c        ****       update_display();
  87:main.c        ****     }else if ((!(PIND & (1 << GEAR_SHIFT_DOWN))) && dwnState == 0){  //if shift down detected
  88:main.c        ****       gearCount --;
  89:main.c        ****       if(gearCount < 0){
  90:main.c        ****         gearCount = 0;
  91:main.c        ****       }
  92:main.c        ****       PORTB |= (1 << SEGMENT_DOT);    // light up the dot marker
  93:main.c        ****       dwnState = 1;
 134               		.loc 1 93 0
 135               	/* #NOAPP */
 136 0042 C1E0      		ldi r28,lo8(1)
 137               	.L12:
  68:main.c        ****       secondFlag = 0;
 138               		.loc 1 68 0
 139 0044 8091 0000 		lds r24,secondFlag
 140 0048 8823      		tst r24
 141 004a 01F0      		breq .L4
  69:main.c        ****       update_display();
 142               		.loc 1 69 0
 143 004c 1092 0000 		sts secondFlag,__zero_reg__
  70:main.c        ****       PORTB ^= (1 << SEGMENT_DOT);    // toggles the led
 144               		.loc 1 70 0
 145 0050 00D0      		rcall update_display
 146               	.LVL1:
  71:main.c        ****     }
 147               		.loc 1 71 0
 148 0052 88B3      		in r24,0x18
 149 0054 8058      		subi r24,lo8(-(-128))
 150 0056 88BB      		out 0x18,r24
 151               	.L4:
  75:main.c        ****       upState = 0;
 152               		.loc 1 75 0
 153 0058 809B      		sbis 0x10,0
 154 005a 00C0      		rjmp .L5
  75:main.c        ****       upState = 0;
 155               		.loc 1 75 0 is_stmt 0 discriminator 1
 156 005c 8091 0000 		lds r24,upState
 157 0060 8130      		cpi r24,lo8(1)
 158 0062 01F4      		brne .L5
  76:main.c        ****     }else if ((PIND & (1 << GEAR_SHIFT_DOWN)) && dwnState == 1){ //reset down debounce
 159               		.loc 1 76 0 is_stmt 1
 160 0064 1092 0000 		sts upState,__zero_reg__
 161 0068 00C0      		rjmp .L6
 162               	.L5:
  77:main.c        ****       dwnState = 0;
 163               		.loc 1 77 0
 164 006a 819B      		sbis 0x10,1
 165 006c 00C0      		rjmp .L7
  77:main.c        ****       dwnState = 0;
 166               		.loc 1 77 0 is_stmt 0 discriminator 1
 167 006e 8091 0000 		lds r24,dwnState
 168 0072 8130      		cpi r24,lo8(1)
 169 0074 01F4      		brne .L7
  78:main.c        ****     } else if ((!(PIND & (1 << GEAR_SHIFT_UP))) && upState == 0){  //if shift up detected
 170               		.loc 1 78 0 is_stmt 1
 171 0076 1092 0000 		sts dwnState,__zero_reg__
 172 007a 00C0      		rjmp .L6
 173               	.L7:
  79:main.c        ****       gearCount ++;
 174               		.loc 1 79 0
 175 007c 8099      		sbic 0x10,0
 176 007e 00C0      		rjmp .L8
  79:main.c        ****       gearCount ++;
 177               		.loc 1 79 0 is_stmt 0 discriminator 1
 178 0080 8091 0000 		lds r24,upState
 179 0084 8111      		cpse r24,__zero_reg__
 180 0086 00C0      		rjmp .L8
  80:main.c        ****       if(gearCount > 15){
 181               		.loc 1 80 0 is_stmt 1
 182 0088 8091 0000 		lds r24,gearCount
 183 008c 8F5F      		subi r24,lo8(-(1))
  81:main.c        ****         gearCount = 0;
 184               		.loc 1 81 0
 185 008e 8031      		cpi r24,lo8(16)
 186 0090 00F4      		brsh .L9
  80:main.c        ****       if(gearCount > 15){
 187               		.loc 1 80 0
 188 0092 8093 0000 		sts gearCount,r24
 189 0096 00C0      		rjmp .L10
 190               	.L9:
  82:main.c        ****       }
 191               		.loc 1 82 0
 192 0098 1092 0000 		sts gearCount,__zero_reg__
 193               	.L10:
  84:main.c        ****       upState = 1;
 194               		.loc 1 84 0
 195 009c C79A      		sbi 0x18,7
  85:main.c        ****       update_display();
 196               		.loc 1 85 0
 197 009e C093 0000 		sts upState,r28
 198 00a2 00C0      		rjmp .L24
 199               	.L8:
  87:main.c        ****       gearCount --;
 200               		.loc 1 87 0
 201 00a4 8199      		sbic 0x10,1
 202 00a6 00C0      		rjmp .L11
  87:main.c        ****       gearCount --;
 203               		.loc 1 87 0 is_stmt 0 discriminator 1
 204 00a8 8091 0000 		lds r24,dwnState
 205 00ac 8111      		cpse r24,__zero_reg__
 206 00ae 00C0      		rjmp .L11
  88:main.c        ****       if(gearCount < 0){
 207               		.loc 1 88 0 is_stmt 1
 208 00b0 8091 0000 		lds r24,gearCount
 209 00b4 8150      		subi r24,lo8(-(-1))
 210 00b6 8093 0000 		sts gearCount,r24
  92:main.c        ****       dwnState = 1;
 211               		.loc 1 92 0
 212 00ba C79A      		sbi 0x18,7
 213               		.loc 1 93 0
 214 00bc C093 0000 		sts dwnState,r28
 215               	.L24:
  94:main.c        ****       update_display();
 216               		.loc 1 94 0
 217 00c0 00D0      		rcall update_display
 218               	.LVL2:
 219 00c2 00C0      		rjmp .L6
 220               	.L11:
  95:main.c        ****     }else if (!(PIND & (1 << RESET_ALL))){  //if reset button pressed
 221               		.loc 1 95 0
 222 00c4 8299      		sbic 0x10,2
 223 00c6 00C0      		rjmp .L6
  96:main.c        ****       //reset the gear state stored in eeprom if it has any previous value
  97:main.c        ****       cli();//Disable Global Interrupts
 224               		.loc 1 97 0
 225               	/* #APP */
 226               	 ;  97 "main.c" 1
 227 00c8 F894      		cli
 228               	 ;  0 "" 2
  98:main.c        ****       valueRead = eeprom_read_byte((uint8_t*)EEPROM_STORAGE_ADDRESS);//read eeprom
 229               		.loc 1 98 0
 230               	/* #NOAPP */
 231 00ca 88E0      		ldi r24,lo8(8)
 232 00cc 90E0      		ldi r25,0
 233 00ce 00D0      		rcall eeprom_read_byte
 234               	.LVL3:
 235 00d0 8093 0000 		sts valueRead,r24
  99:main.c        ****       eeprom_write_byte((uint8_t*)EEPROM_STORAGE_ADDRESS,0);//write eeprom
 236               		.loc 1 99 0
 237 00d4 60E0      		ldi r22,0
 238 00d6 88E0      		ldi r24,lo8(8)
 239 00d8 90E0      		ldi r25,0
 240 00da 00D0      		rcall eeprom_write_byte
 241               	.LVL4:
 100:main.c        ****       gearCount = 0;
 242               		.loc 1 100 0
 243 00dc 1092 0000 		sts gearCount,__zero_reg__
 101:main.c        ****       PORTB |= (1 << SEGMENT_DOT);    // light up the dot marker
 244               		.loc 1 101 0
 245 00e0 C79A      		sbi 0x18,7
 246               	.LVL5:
 247               	.LBB6:
 248               	.LBB7:
 249               		.file 2 "c:\\winavr\\avr\\include\\util\\delay.h"
   1:c:\winavr\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr\avr\include\util\delay.h **** 
   6:c:\winavr\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr\avr\include\util\delay.h **** 
   9:c:\winavr\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr\avr\include\util\delay.h **** 
  12:c:\winavr\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr\avr\include\util\delay.h ****      distribution.
  16:c:\winavr\avr\include\util\delay.h **** 
  17:c:\winavr\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr\avr\include\util\delay.h **** 
  21:c:\winavr\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr\avr\include\util\delay.h **** 
  33:c:\winavr\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr\avr\include\util\delay.h **** 
  35:c:\winavr\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr\avr\include\util\delay.h **** 
  38:c:\winavr\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\winavr\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\winavr\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\winavr\avr\include\util\delay.h **** #  endif
  42:c:\winavr\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\winavr\avr\include\util\delay.h **** 
  44:c:\winavr\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\winavr\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\winavr\avr\include\util\delay.h **** #include <math.h>
  47:c:\winavr\avr\include\util\delay.h **** 
  48:c:\winavr\avr\include\util\delay.h **** /** \file */
  49:c:\winavr\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\winavr\avr\include\util\delay.h ****     \code
  51:c:\winavr\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\winavr\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\winavr\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\winavr\avr\include\util\delay.h ****     \endcode
  55:c:\winavr\avr\include\util\delay.h **** 
  56:c:\winavr\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\winavr\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\winavr\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\winavr\avr\include\util\delay.h ****     used.
  60:c:\winavr\avr\include\util\delay.h **** 
  61:c:\winavr\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\winavr\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\winavr\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\winavr\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\winavr\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\winavr\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\winavr\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\winavr\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\winavr\avr\include\util\delay.h **** 
  70:c:\winavr\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\winavr\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\winavr\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\winavr\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\winavr\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\winavr\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\winavr\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\winavr\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\winavr\avr\include\util\delay.h **** 
  79:c:\winavr\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\winavr\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\winavr\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\winavr\avr\include\util\delay.h **** 
  83:c:\winavr\avr\include\util\delay.h **** */
  84:c:\winavr\avr\include\util\delay.h **** 
  85:c:\winavr\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\winavr\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\winavr\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\winavr\avr\include\util\delay.h **** #endif
  89:c:\winavr\avr\include\util\delay.h **** 
  90:c:\winavr\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\winavr\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\winavr\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\winavr\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\winavr\avr\include\util\delay.h ****     \def F_CPU
  95:c:\winavr\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\winavr\avr\include\util\delay.h **** 
  97:c:\winavr\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\winavr\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\winavr\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\winavr\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\winavr\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\winavr\avr\include\util\delay.h **** 
 103:c:\winavr\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\winavr\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\winavr\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\winavr\avr\include\util\delay.h ****     integer value.
 107:c:\winavr\avr\include\util\delay.h ****  */
 108:c:\winavr\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\winavr\avr\include\util\delay.h **** #endif
 110:c:\winavr\avr\include\util\delay.h **** 
 111:c:\winavr\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\winavr\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\winavr\avr\include\util\delay.h **** #endif
 114:c:\winavr\avr\include\util\delay.h **** 
 115:c:\winavr\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\winavr\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\winavr\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\winavr\avr\include\util\delay.h **** #  include <math.h>
 119:c:\winavr\avr\include\util\delay.h **** #endif
 120:c:\winavr\avr\include\util\delay.h **** 
 121:c:\winavr\avr\include\util\delay.h **** /**
 122:c:\winavr\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\winavr\avr\include\util\delay.h **** 
 124:c:\winavr\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\winavr\avr\include\util\delay.h **** 
 126:c:\winavr\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\winavr\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\winavr\avr\include\util\delay.h **** 
 129:c:\winavr\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\winavr\avr\include\util\delay.h **** 
 131:c:\winavr\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\winavr\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\winavr\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\winavr\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\winavr\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\winavr\avr\include\util\delay.h **** 
 137:c:\winavr\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\winavr\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\winavr\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\winavr\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\winavr\avr\include\util\delay.h **** 
 142:c:\winavr\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\winavr\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\winavr\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\winavr\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\winavr\avr\include\util\delay.h **** 
 147:c:\winavr\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\winavr\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\winavr\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\winavr\avr\include\util\delay.h ****    respectively.
 151:c:\winavr\avr\include\util\delay.h **** 
 152:c:\winavr\avr\include\util\delay.h ****    \note
 153:c:\winavr\avr\include\util\delay.h **** 
 154:c:\winavr\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\winavr\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\winavr\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\winavr\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\winavr\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\winavr\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\winavr\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\winavr\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\winavr\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\winavr\avr\include\util\delay.h **** 
 164:c:\winavr\avr\include\util\delay.h ****  */
 165:c:\winavr\avr\include\util\delay.h **** void
 166:c:\winavr\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\winavr\avr\include\util\delay.h **** {
 168:c:\winavr\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\winavr\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\winavr\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\winavr\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\winavr\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\winavr\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\winavr\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\winavr\avr\include\util\delay.h **** 
 176:c:\winavr\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\winavr\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\winavr\avr\include\util\delay.h **** 
 179:c:\winavr\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\winavr\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\winavr\avr\include\util\delay.h **** 
 182:c:\winavr\avr\include\util\delay.h **** 	#else
 183:c:\winavr\avr\include\util\delay.h **** 		//round up by default
 184:c:\winavr\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\winavr\avr\include\util\delay.h **** 	#endif
 186:c:\winavr\avr\include\util\delay.h **** 
 187:c:\winavr\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 250               		.loc 2 187 0
 251 00e2 2FE3      		ldi r18,lo8(199999)
 252 00e4 8DE0      		ldi r24,hi8(199999)
 253 00e6 93E0      		ldi r25,hlo8(199999)
 254 00e8 2150      	1:	subi r18,1
 255 00ea 8040      		sbci r24,0
 256 00ec 9040      		sbci r25,0
 257 00ee 01F4      		brne 1b
 258 00f0 00C0      		rjmp .
 259 00f2 0000      		nop
 260               	.LVL6:
 261               	.LBE7:
 262               	.LBE6:
 102:main.c        ****       _delay_ms(1000);
 103:main.c        ****       sei();//Enable Global Interrupts
 263               		.loc 1 103 0
 264               	/* #APP */
 265               	 ;  103 "main.c" 1
 266 00f4 7894      		sei
 267               	 ;  0 "" 2
 268               	/* #NOAPP */
 269               	.L6:
 104:main.c        ****     }
 105:main.c        **** 
 106:main.c        ****     //-------------------------------POWER DOWN, SAVE IMMEDIATELY TO EEPROM
 107:main.c        ****     if (!(PIND & (1 << POWER_OFF_DETECT))){ //active low
 270               		.loc 1 107 0
 271 00f6 8499      		sbic 0x10,4
 272 00f8 00C0      		rjmp .L12
 108:main.c        ****       cli();//Disable Global Interrupts
 273               		.loc 1 108 0
 274               	/* #APP */
 275               	 ;  108 "main.c" 1
 276 00fa F894      		cli
 277               	 ;  0 "" 2
 109:main.c        ****       eeprom_write_byte((uint8_t*)EEPROM_STORAGE_ADDRESS, gearCount);//write eeprom
 278               		.loc 1 109 0
 279               	/* #NOAPP */
 280 00fc 6091 0000 		lds r22,gearCount
 281 0100 88E0      		ldi r24,lo8(8)
 282 0102 90E0      		ldi r25,0
 283 0104 00D0      		rcall eeprom_write_byte
 284               	.LVL7:
 110:main.c        ****       PORTB |= (1 << SEGMENT_DOT);    // light up the dot marker
 285               		.loc 1 110 0
 286 0106 C79A      		sbi 0x18,7
 287               	.LVL8:
 288               	.LBB8:
 289               	.LBB9:
 290               		.loc 2 187 0
 291 0108 2FE9      		ldi r18,lo8(99999)
 292 010a 86E8      		ldi r24,hi8(99999)
 293 010c 91E0      		ldi r25,hlo8(99999)
 294 010e 2150      	1:	subi r18,1
 295 0110 8040      		sbci r24,0
 296 0112 9040      		sbci r25,0
 297 0114 01F4      		brne 1b
 298 0116 00C0      		rjmp .
 299 0118 0000      		nop
 300               	.LVL9:
 301               	.LBE9:
 302               	.LBE8:
 111:main.c        ****       _delay_ms(500); //delay till the capacitor discharge
 112:main.c        ****       sei();//Enable Global Interrupts
 303               		.loc 1 112 0
 304               	/* #APP */
 305               	 ;  112 "main.c" 1
 306 011a 7894      		sei
 307               	 ;  0 "" 2
 308               	/* #NOAPP */
 309 011c 00C0      		rjmp .L12
 310               		.cfi_endproc
 311               	.LFE8:
 313               	.global	states_of_segment
 314               		.data
 317               	states_of_segment:
 318 0000 3F        		.byte	63
 319 0001 06        		.byte	6
 320 0002 5B        		.byte	91
 321 0003 4F        		.byte	79
 322 0004 66        		.byte	102
 323 0005 6D        		.byte	109
 324 0006 7D        		.byte	125
 325 0007 07        		.byte	7
 326 0008 7F        		.byte	127
 327 0009 6F        		.byte	111
 328 000a 77        		.byte	119
 329 000b 7C        		.byte	124
 330 000c 39        		.byte	57
 331 000d 5E        		.byte	94
 332 000e 79        		.byte	121
 333 000f 71        		.byte	113
 334               	.global	buttonPressed
 335               		.section .bss
 338               	buttonPressed:
 339 0000 00        		.zero	1
 340               	.global	valueRead
 343               	valueRead:
 344 0001 00        		.zero	1
 345               	.global	gearCount
 348               	gearCount:
 349 0002 00        		.zero	1
 350               	.global	dwnState
 353               	dwnState:
 354 0003 00        		.zero	1
 355               	.global	upState
 358               	upState:
 359 0004 00        		.zero	1
 360               		.comm	secondFlag,1,1
 361               		.text
 362               	.Letext0:
 363               		.file 3 "c:\\winavr\\avr\\include\\stdint.h"
 364               		.file 4 "c:\\winavr\\avr\\include\\avr\\eeprom.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Khairul\AppData\Local\Temp\ccR28TKj.s:2      *ABS*:0000003e __SP_H__
C:\Users\Khairul\AppData\Local\Temp\ccR28TKj.s:3      *ABS*:0000003d __SP_L__
C:\Users\Khairul\AppData\Local\Temp\ccR28TKj.s:4      *ABS*:0000003f __SREG__
C:\Users\Khairul\AppData\Local\Temp\ccR28TKj.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Khairul\AppData\Local\Temp\ccR28TKj.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Khairul\AppData\Local\Temp\ccR28TKj.s:12     .text:00000000 __vector_6
                            *COM*:00000001 secondFlag
C:\Users\Khairul\AppData\Local\Temp\ccR28TKj.s:52     .text:0000001e update_display
C:\Users\Khairul\AppData\Local\Temp\ccR28TKj.s:348    .bss:00000002 gearCount
C:\Users\Khairul\AppData\Local\Temp\ccR28TKj.s:317    .data:00000000 states_of_segment
C:\Users\Khairul\AppData\Local\Temp\ccR28TKj.s:80     .text.startup:00000000 main
C:\Users\Khairul\AppData\Local\Temp\ccR28TKj.s:343    .bss:00000001 valueRead
C:\Users\Khairul\AppData\Local\Temp\ccR28TKj.s:358    .bss:00000004 upState
C:\Users\Khairul\AppData\Local\Temp\ccR28TKj.s:353    .bss:00000003 dwnState
C:\Users\Khairul\AppData\Local\Temp\ccR28TKj.s:338    .bss:00000000 buttonPressed

UNDEFINED SYMBOLS
eeprom_read_byte
eeprom_write_byte
__do_copy_data
__do_clear_bss
