   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	__vector_6
  12               	__vector_6:
  13               	.LFB6:
  14               		.file 1 "main.c"
   1:main.c        **** //**************************************************
   2:main.c        **** //  Author    - Md. Khairul Hasan
   3:main.c        **** //  Contact   - +880-1719-328628, 
   4:main.c        **** //  e-mail    - kairulhasanmd@gmail.com
   5:main.c        **** //  Device    - Hall effect sensor based motorcycle gear indicator.
   6:main.c        **** // **************************************************
   7:main.c        **** 
   8:main.c        **** // avrdude -p atmega8 -c usbasp -t -B 3
   9:main.c        **** // dump eeprom 0 512
  10:main.c        **** #include <avr/eeprom.h>
  11:main.c        **** #include <avr/io.h>
  12:main.c        **** #include <avr/interrupt.h>
  13:main.c        **** #include <util/delay.h>
  14:main.c        **** 
  15:main.c        **** #define F_CPU 1000000UL
  16:main.c        **** #define EEPROM_STORAGE_ADDRESS 0x08
  17:main.c        **** #define POWER_OFF_DETECT PD4
  18:main.c        **** #define SEGMENT_DOT PB7
  19:main.c        **** #define GEAR_SHIFT_UP PD0
  20:main.c        **** #define GEAR_SHIFT_DOWN PD1
  21:main.c        **** #define RESET_ALL PD2
  22:main.c        **** 
  23:main.c        **** volatile uint8_t secondFlag;
  24:main.c        **** uint8_t gearState = 0;
  25:main.c        **** uint8_t valueRead = 0;
  26:main.c        **** uint8_t buttonPressed = 0; 
  27:main.c        **** uint8_t states_of_segment[16] = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F, 0x77, 
  28:main.c        **** 
  29:main.c        **** ISR(TIMER1_COMPA_vect)
  30:main.c        **** {
  15               		.loc 1 30 0
  16               		.cfi_startproc
  17 0000 1F92      		push r1
  18               	.LCFI0:
  19               		.cfi_def_cfa_offset 3
  20               		.cfi_offset 1, -2
  21 0002 0F92      		push r0
  22               	.LCFI1:
  23               		.cfi_def_cfa_offset 4
  24               		.cfi_offset 0, -3
  25 0004 0FB6      		in r0,__SREG__
  26 0006 0F92      		push r0
  27 0008 1124      		clr __zero_reg__
  28 000a 8F93      		push r24
  29               	.LCFI2:
  30               		.cfi_def_cfa_offset 5
  31               		.cfi_offset 24, -4
  32               	/* prologue: Signal */
  33               	/* frame size = 0 */
  34               	/* stack size = 4 */
  35               	.L__stack_usage = 4
  31:main.c        ****   secondFlag = 1;
  36               		.loc 1 31 0
  37 000c 81E0      		ldi r24,lo8(1)
  38 000e 8093 0000 		sts secondFlag,r24
  39               	/* epilogue start */
  32:main.c        **** }
  40               		.loc 1 32 0
  41 0012 8F91      		pop r24
  42 0014 0F90      		pop r0
  43 0016 0FBE      		out __SREG__,r0
  44 0018 0F90      		pop r0
  45 001a 1F90      		pop r1
  46 001c 1895      		reti
  47               		.cfi_endproc
  48               	.LFE6:
  50               		.section	.text.startup,"ax",@progbits
  51               	.global	main
  53               	main:
  54               	.LFB7:
  33:main.c        **** 
  34:main.c        **** int main (void)
  35:main.c        **** {
  55               		.loc 1 35 0
  56               		.cfi_startproc
  57               	/* prologue: function */
  58               	/* frame size = 0 */
  59               	/* stack size = 0 */
  60               	.L__stack_usage = 0
  36:main.c        ****   //initialize the I/O Ports
  37:main.c        ****   DDRC |= (1 << PC5)|(1 << PC4)|(1 << PC3)|(1 << PC2); //led in pc5,4,3,2,pins
  61               		.loc 1 37 0
  62 0000 84B3      		in r24,0x14
  63 0002 8C63      		ori r24,lo8(60)
  64 0004 84BB      		out 0x14,r24
  38:main.c        ****   DDRB |= (1 << PB0)|(1 << PB1)|(1 << PB2)|(1 << PB3)|(1 << PB4)|(1 << PB5)|(1 << PB6)|(1 << SEGMEN
  65               		.loc 1 38 0
  66 0006 87B3      		in r24,0x17
  67 0008 8FEF      		ldi r24,lo8(-1)
  68 000a 87BB      		out 0x17,r24
  39:main.c        ****   DDRD &= ~((1 << GEAR_SHIFT_UP)|(1 << GEAR_SHIFT_DOWN)|(1 << RESET_ALL)|(1 << POWER_OFF_DETECT)); 
  69               		.loc 1 39 0
  70 000c 81B3      		in r24,0x11
  71 000e 887E      		andi r24,lo8(-24)
  72 0010 81BB      		out 0x11,r24
  40:main.c        ****   PORTD |= (1 << GEAR_SHIFT_UP)|(1 << GEAR_SHIFT_DOWN)|(1 << RESET_ALL)|(1 << POWER_OFF_DETECT);   
  73               		.loc 1 40 0
  74 0012 82B3      		in r24,0x12
  75 0014 8761      		ori r24,lo8(23)
  76 0016 82BB      		out 0x12,r24
  41:main.c        **** 
  42:main.c        ****   TCCR1B |= (1 << WGM12);           // Configure timer 1 for CTC mode
  77               		.loc 1 42 0
  78 0018 8EB5      		in r24,0x2e
  79 001a 8860      		ori r24,lo8(8)
  80 001c 8EBD      		out 0x2e,r24
  43:main.c        ****   TIMSK |= (1 << OCIE1A);           // Enable CTC interrupt
  81               		.loc 1 43 0
  82 001e 89B7      		in r24,0x39
  83 0020 8061      		ori r24,lo8(16)
  84 0022 89BF      		out 0x39,r24
  44:main.c        ****   OCR1A = 15624;                // Set CTC compare value to 1Hz at 1MHz AVR clock, with a prescaler
  85               		.loc 1 44 0
  86 0024 88E0      		ldi r24,lo8(8)
  87 0026 9DE3      		ldi r25,lo8(61)
  88 0028 9BBD      		out 0x2a+1,r25
  89 002a 8ABD      		out 0x2a,r24
  45:main.c        ****   TCCR1B |= ((1 << CS10) | (1 << CS11));  // Start timer at Fcpu/64
  90               		.loc 1 45 0
  91 002c 8EB5      		in r24,0x2e
  92 002e 8360      		ori r24,lo8(3)
  93 0030 8EBD      		out 0x2e,r24
  46:main.c        **** 
  47:main.c        ****   //READ FROM EEPROM
  48:main.c        ****   valueRead = eeprom_read_byte((uint8_t*)EEPROM_STORAGE_ADDRESS);//read eeprom
  94               		.loc 1 48 0
  95 0032 88E0      		ldi r24,lo8(8)
  96 0034 90E0      		ldi r25,0
  97 0036 00D0      		rcall eeprom_read_byte
  98               	.LVL0:
  99 0038 8093 0000 		sts valueRead,r24
  49:main.c        ****   if (valueRead == 0xFFFF)//initial value.. omit it 
  50:main.c        ****   {
  51:main.c        ****     gearState = 0;
  52:main.c        ****   }else{//has some value and its larger 
  53:main.c        ****     gearState = valueRead;
 100               		.loc 1 53 0
 101 003c 8093 0000 		sts gearState,r24
 102               	.L15:
  54:main.c        ****   }
  55:main.c        ****   sei();//Enable Global Interrupts
 103               		.loc 1 55 0
 104               	/* #APP */
 105               	 ;  55 "main.c" 1
 106 0040 7894      		sei
 107               	 ;  0 "" 2
 108               	/* #NOAPP */
 109               	.L9:
  56:main.c        **** 
  57:main.c        ****   while (1)//main loop 
  58:main.c        ****   {
  59:main.c        ****     if (secondFlag){
 110               		.loc 1 59 0
 111 0042 8091 0000 		lds r24,secondFlag
 112 0046 8823      		tst r24
 113 0048 01F0      		breq .L3
  60:main.c        ****       secondFlag = 0;
 114               		.loc 1 60 0
 115 004a 1092 0000 		sts secondFlag,__zero_reg__
  61:main.c        ****       // gearState ++;
  62:main.c        ****       // if(gearState > 15){
  63:main.c        ****       //   gearState = 0;
  64:main.c        ****       // }
  65:main.c        ****       PORTB &= 0b10000000;
 116               		.loc 1 65 0
 117 004e 88B3      		in r24,0x18
 118 0050 8078      		andi r24,lo8(-128)
 119 0052 88BB      		out 0x18,r24
  66:main.c        ****       PORTB |= states_of_segment[gearState];
 120               		.loc 1 66 0
 121 0054 98B3      		in r25,0x18
 122 0056 E091 0000 		lds r30,gearState
 123 005a F0E0      		ldi r31,0
 124 005c E050      		subi r30,lo8(-(states_of_segment))
 125 005e F040      		sbci r31,hi8(-(states_of_segment))
 126 0060 8081      		ld r24,Z
 127 0062 892B      		or r24,r25
 128 0064 88BB      		out 0x18,r24
  67:main.c        ****       PORTB ^= (1 << SEGMENT_DOT);    // toggles the led
 129               		.loc 1 67 0
 130 0066 88B3      		in r24,0x18
 131 0068 8058      		subi r24,lo8(-(-128))
 132 006a 88BB      		out 0x18,r24
 133               	.L3:
  68:main.c        ****     }
  69:main.c        **** 
  70:main.c        ****     //hall effect sensor functionality
  71:main.c        ****     if (!(PIND & (1 << GEAR_SHIFT_UP))){  //if shift up detected
 134               		.loc 1 71 0
 135 006c 8099      		sbic 0x10,0
 136 006e 00C0      		rjmp .L4
  72:main.c        ****       gearState ++;
 137               		.loc 1 72 0
 138 0070 8091 0000 		lds r24,gearState
 139 0074 8F5F      		subi r24,lo8(-(1))
  73:main.c        ****       if(gearState > 15){
 140               		.loc 1 73 0
 141 0076 8031      		cpi r24,lo8(16)
 142 0078 00F0      		brlo .L17
  74:main.c        ****         gearState = 0;
 143               		.loc 1 74 0
 144 007a 1092 0000 		sts gearState,__zero_reg__
 145 007e 00C0      		rjmp .L16
 146               	.L4:
  75:main.c        ****       }
  76:main.c        ****       PORTB |= (1 << SEGMENT_DOT);    // light up the dot marker
  77:main.c        ****     }else if (!(PIND & (1 << GEAR_SHIFT_DOWN))){  //if shift down detected
 147               		.loc 1 77 0
 148 0080 8199      		sbic 0x10,1
 149 0082 00C0      		rjmp .L8
  78:main.c        ****       gearState --;
 150               		.loc 1 78 0
 151 0084 8091 0000 		lds r24,gearState
 152 0088 8150      		subi r24,lo8(-(-1))
 153               	.L17:
 154 008a 8093 0000 		sts gearState,r24
 155               	.L16:
  79:main.c        ****       if(gearState < 0){
  80:main.c        ****         gearState = 0;
  81:main.c        ****       }
  82:main.c        ****       PORTB |= (1 << SEGMENT_DOT);    // light up the dot marker
 156               		.loc 1 82 0
 157 008e C79A      		sbi 0x18,7
 158 0090 00C0      		rjmp .L7
 159               	.L8:
  83:main.c        ****     }else if (!(PIND & (1 << RESET_ALL))){  //if reset button pressed
 160               		.loc 1 83 0
 161 0092 8299      		sbic 0x10,2
 162 0094 00C0      		rjmp .L7
  84:main.c        ****       //reset the gear state stored in eeprom if it has any previous value
  85:main.c        ****       cli();//Disable Global Interrupts
 163               		.loc 1 85 0
 164               	/* #APP */
 165               	 ;  85 "main.c" 1
 166 0096 F894      		cli
 167               	 ;  0 "" 2
  86:main.c        ****       valueRead = eeprom_read_byte((uint8_t*)EEPROM_STORAGE_ADDRESS);//read eeprom
 168               		.loc 1 86 0
 169               	/* #NOAPP */
 170 0098 88E0      		ldi r24,lo8(8)
 171 009a 90E0      		ldi r25,0
 172 009c 00D0      		rcall eeprom_read_byte
 173               	.LVL1:
 174 009e 8093 0000 		sts valueRead,r24
  87:main.c        ****       eeprom_write_byte((uint8_t*)EEPROM_STORAGE_ADDRESS,0);//write eeprom
 175               		.loc 1 87 0
 176 00a2 60E0      		ldi r22,0
 177 00a4 88E0      		ldi r24,lo8(8)
 178 00a6 90E0      		ldi r25,0
 179 00a8 00D0      		rcall eeprom_write_byte
 180               	.LVL2:
  88:main.c        ****       gearState = 0;
 181               		.loc 1 88 0
 182 00aa 1092 0000 		sts gearState,__zero_reg__
  89:main.c        ****       PORTB |= (1 << SEGMENT_DOT);    // light up the dot marker
 183               		.loc 1 89 0
 184 00ae C79A      		sbi 0x18,7
 185               	.LVL3:
 186               	.LBB6:
 187               	.LBB7:
 188               		.file 2 "c:\\winavr\\avr\\include\\util\\delay.h"
   1:c:\winavr\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr\avr\include\util\delay.h **** 
   6:c:\winavr\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr\avr\include\util\delay.h **** 
   9:c:\winavr\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr\avr\include\util\delay.h **** 
  12:c:\winavr\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr\avr\include\util\delay.h ****      distribution.
  16:c:\winavr\avr\include\util\delay.h **** 
  17:c:\winavr\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr\avr\include\util\delay.h **** 
  21:c:\winavr\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr\avr\include\util\delay.h **** 
  33:c:\winavr\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr\avr\include\util\delay.h **** 
  35:c:\winavr\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr\avr\include\util\delay.h **** 
  38:c:\winavr\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\winavr\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\winavr\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\winavr\avr\include\util\delay.h **** #  endif
  42:c:\winavr\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\winavr\avr\include\util\delay.h **** 
  44:c:\winavr\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\winavr\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\winavr\avr\include\util\delay.h **** #include <math.h>
  47:c:\winavr\avr\include\util\delay.h **** 
  48:c:\winavr\avr\include\util\delay.h **** /** \file */
  49:c:\winavr\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\winavr\avr\include\util\delay.h ****     \code
  51:c:\winavr\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\winavr\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\winavr\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\winavr\avr\include\util\delay.h ****     \endcode
  55:c:\winavr\avr\include\util\delay.h **** 
  56:c:\winavr\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\winavr\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\winavr\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\winavr\avr\include\util\delay.h ****     used.
  60:c:\winavr\avr\include\util\delay.h **** 
  61:c:\winavr\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\winavr\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\winavr\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\winavr\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\winavr\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\winavr\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\winavr\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\winavr\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\winavr\avr\include\util\delay.h **** 
  70:c:\winavr\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\winavr\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\winavr\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\winavr\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\winavr\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\winavr\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\winavr\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\winavr\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\winavr\avr\include\util\delay.h **** 
  79:c:\winavr\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\winavr\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\winavr\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\winavr\avr\include\util\delay.h **** 
  83:c:\winavr\avr\include\util\delay.h **** */
  84:c:\winavr\avr\include\util\delay.h **** 
  85:c:\winavr\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\winavr\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\winavr\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\winavr\avr\include\util\delay.h **** #endif
  89:c:\winavr\avr\include\util\delay.h **** 
  90:c:\winavr\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\winavr\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\winavr\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\winavr\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\winavr\avr\include\util\delay.h ****     \def F_CPU
  95:c:\winavr\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\winavr\avr\include\util\delay.h **** 
  97:c:\winavr\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\winavr\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\winavr\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\winavr\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\winavr\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\winavr\avr\include\util\delay.h **** 
 103:c:\winavr\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\winavr\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\winavr\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\winavr\avr\include\util\delay.h ****     integer value.
 107:c:\winavr\avr\include\util\delay.h ****  */
 108:c:\winavr\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\winavr\avr\include\util\delay.h **** #endif
 110:c:\winavr\avr\include\util\delay.h **** 
 111:c:\winavr\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\winavr\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\winavr\avr\include\util\delay.h **** #endif
 114:c:\winavr\avr\include\util\delay.h **** 
 115:c:\winavr\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\winavr\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\winavr\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\winavr\avr\include\util\delay.h **** #  include <math.h>
 119:c:\winavr\avr\include\util\delay.h **** #endif
 120:c:\winavr\avr\include\util\delay.h **** 
 121:c:\winavr\avr\include\util\delay.h **** /**
 122:c:\winavr\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\winavr\avr\include\util\delay.h **** 
 124:c:\winavr\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\winavr\avr\include\util\delay.h **** 
 126:c:\winavr\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\winavr\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\winavr\avr\include\util\delay.h **** 
 129:c:\winavr\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\winavr\avr\include\util\delay.h **** 
 131:c:\winavr\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\winavr\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\winavr\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\winavr\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\winavr\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\winavr\avr\include\util\delay.h **** 
 137:c:\winavr\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\winavr\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\winavr\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\winavr\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\winavr\avr\include\util\delay.h **** 
 142:c:\winavr\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\winavr\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\winavr\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\winavr\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\winavr\avr\include\util\delay.h **** 
 147:c:\winavr\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\winavr\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\winavr\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\winavr\avr\include\util\delay.h ****    respectively.
 151:c:\winavr\avr\include\util\delay.h **** 
 152:c:\winavr\avr\include\util\delay.h ****    \note
 153:c:\winavr\avr\include\util\delay.h **** 
 154:c:\winavr\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\winavr\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\winavr\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\winavr\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\winavr\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\winavr\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\winavr\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\winavr\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\winavr\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\winavr\avr\include\util\delay.h **** 
 164:c:\winavr\avr\include\util\delay.h ****  */
 165:c:\winavr\avr\include\util\delay.h **** void
 166:c:\winavr\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\winavr\avr\include\util\delay.h **** {
 168:c:\winavr\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\winavr\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\winavr\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\winavr\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\winavr\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\winavr\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\winavr\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\winavr\avr\include\util\delay.h **** 
 176:c:\winavr\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\winavr\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\winavr\avr\include\util\delay.h **** 
 179:c:\winavr\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\winavr\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\winavr\avr\include\util\delay.h **** 
 182:c:\winavr\avr\include\util\delay.h **** 	#else
 183:c:\winavr\avr\include\util\delay.h **** 		//round up by default
 184:c:\winavr\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\winavr\avr\include\util\delay.h **** 	#endif
 186:c:\winavr\avr\include\util\delay.h **** 
 187:c:\winavr\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 189               		.loc 2 187 0
 190 00b0 2FE3      		ldi r18,lo8(199999)
 191 00b2 8DE0      		ldi r24,hi8(199999)
 192 00b4 93E0      		ldi r25,hlo8(199999)
 193 00b6 2150      	1:	subi r18,1
 194 00b8 8040      		sbci r24,0
 195 00ba 9040      		sbci r25,0
 196 00bc 01F4      		brne 1b
 197 00be 00C0      		rjmp .
 198 00c0 0000      		nop
 199               	.LVL4:
 200               	.LBE7:
 201               	.LBE6:
  90:main.c        ****       _delay_ms(1000);
  91:main.c        ****       sei();//Enable Global Interrupts
 202               		.loc 1 91 0
 203               	/* #APP */
 204               	 ;  91 "main.c" 1
 205 00c2 7894      		sei
 206               	 ;  0 "" 2
 207               	/* #NOAPP */
 208               	.L7:
  92:main.c        ****     }
  93:main.c        **** 
  94:main.c        ****     //-------------------------------POWER DOWN, SAVE IMMEDIATELY TO EEPROM
  95:main.c        ****     if (!(PIND & (1 << POWER_OFF_DETECT))){ //active low
 209               		.loc 1 95 0
 210 00c4 8499      		sbic 0x10,4
 211 00c6 00C0      		rjmp .L9
  96:main.c        ****       cli();//Disable Global Interrupts
 212               		.loc 1 96 0
 213               	/* #APP */
 214               	 ;  96 "main.c" 1
 215 00c8 F894      		cli
 216               	 ;  0 "" 2
  97:main.c        ****       eeprom_write_byte((uint8_t*)EEPROM_STORAGE_ADDRESS, gearState);//write eeprom
 217               		.loc 1 97 0
 218               	/* #NOAPP */
 219 00ca 6091 0000 		lds r22,gearState
 220 00ce 88E0      		ldi r24,lo8(8)
 221 00d0 90E0      		ldi r25,0
 222 00d2 00D0      		rcall eeprom_write_byte
 223               	.LVL5:
  98:main.c        ****       PORTB |= (1 << SEGMENT_DOT);    // light up the dot marker
 224               		.loc 1 98 0
 225 00d4 C79A      		sbi 0x18,7
 226               	.LVL6:
 227               	.LBB8:
 228               	.LBB9:
 229               		.loc 2 187 0
 230 00d6 2FE9      		ldi r18,lo8(99999)
 231 00d8 86E8      		ldi r24,hi8(99999)
 232 00da 91E0      		ldi r25,hlo8(99999)
 233 00dc 2150      	1:	subi r18,1
 234 00de 8040      		sbci r24,0
 235 00e0 9040      		sbci r25,0
 236 00e2 01F4      		brne 1b
 237 00e4 00C0      		rjmp .
 238 00e6 0000      		nop
 239               	.LVL7:
 240 00e8 00C0      		rjmp .L15
 241               	.LBE9:
 242               	.LBE8:
 243               		.cfi_endproc
 244               	.LFE7:
 246               	.global	states_of_segment
 247               		.data
 250               	states_of_segment:
 251 0000 3F        		.byte	63
 252 0001 06        		.byte	6
 253 0002 5B        		.byte	91
 254 0003 4F        		.byte	79
 255 0004 66        		.byte	102
 256 0005 6D        		.byte	109
 257 0006 7D        		.byte	125
 258 0007 07        		.byte	7
 259 0008 7F        		.byte	127
 260 0009 6F        		.byte	111
 261 000a 77        		.byte	119
 262 000b 7C        		.byte	124
 263 000c 39        		.byte	57
 264 000d 5E        		.byte	94
 265 000e 79        		.byte	121
 266 000f 71        		.byte	113
 267               	.global	buttonPressed
 268               		.section .bss
 271               	buttonPressed:
 272 0000 00        		.zero	1
 273               	.global	valueRead
 276               	valueRead:
 277 0001 00        		.zero	1
 278               	.global	gearState
 281               	gearState:
 282 0002 00        		.zero	1
 283               		.comm	secondFlag,1,1
 284               		.text
 285               	.Letext0:
 286               		.file 3 "c:\\winavr\\avr\\include\\stdint.h"
 287               		.file 4 "c:\\winavr\\avr\\include\\avr\\eeprom.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Khairul\AppData\Local\Temp\ccGpqHpV.s:2      *ABS*:0000003e __SP_H__
C:\Users\Khairul\AppData\Local\Temp\ccGpqHpV.s:3      *ABS*:0000003d __SP_L__
C:\Users\Khairul\AppData\Local\Temp\ccGpqHpV.s:4      *ABS*:0000003f __SREG__
C:\Users\Khairul\AppData\Local\Temp\ccGpqHpV.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Khairul\AppData\Local\Temp\ccGpqHpV.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Khairul\AppData\Local\Temp\ccGpqHpV.s:12     .text:00000000 __vector_6
                            *COM*:00000001 secondFlag
C:\Users\Khairul\AppData\Local\Temp\ccGpqHpV.s:53     .text.startup:00000000 main
C:\Users\Khairul\AppData\Local\Temp\ccGpqHpV.s:276    .bss:00000001 valueRead
C:\Users\Khairul\AppData\Local\Temp\ccGpqHpV.s:281    .bss:00000002 gearState
C:\Users\Khairul\AppData\Local\Temp\ccGpqHpV.s:250    .data:00000000 states_of_segment
C:\Users\Khairul\AppData\Local\Temp\ccGpqHpV.s:271    .bss:00000000 buttonPressed

UNDEFINED SYMBOLS
eeprom_read_byte
eeprom_write_byte
__do_copy_data
__do_clear_bss
